# =============================================================================

# PARTE 9: AN√ÅLISE MULTIVARIADA DE COVARI√ÅVEIS (COVARIATE SHIFT)

# =============================================================================

def selecionar_features_relevantes(df_merged):
‚Äú‚Äù‚Äù
Seleciona features de calend√°rio relevantes para an√°lise de covariate shift.

```
Args:
    df_merged: DataFrame com dados completos
    
Returns:
    features_selecionadas: Lista com nomes das features
    df_features: DataFrame apenas com as features selecionadas
"""
print("\nüìä Selecionando features para an√°lise de covariate shift...")

# Features principais do calend√°rio banc√°rio
features_candidatas = [
    'DIA_SEMANA', 'MES', 'DIA_MES', 'SEMANA_MES',
    'DIA_FERIADO', 'DIA_UTIL', 'DIA_FERIADO_UTIL',
    'QTD_DIAS_FECHADO_DEPOIS_NUM', 'QTD_DIAS_FECHADO_ANTES_NUM',
    'SEQ_DIA_UTIL', 'SEQ_DIA_UTIL_NEG',
    'NUM_DIAS_UTEIS_MAIS_7_DIAS', 'NUM_DIAS_UTEIS_MENOS_7_DIAS',
    'EMENDA', 'DIA_ADJACENTE_FERIADO', 'FDS_DE_FERIADO',
    'SEMANA_QUINTO_DU', 'SEMANA_ANTERIOR_QUINTO_DU', 'SEMANA_APOS_QUINTO_DU'
]

# Verificar quais features existem no dataframe
features_disponiveis = [f for f in features_candidatas if f in df_merged.columns]

# Adicionar features DIA_MES_AJUSTADO que estiverem presentes
features_dia_mes = [col for col in df_merged.columns if col.startswith('DIA_MES_AJUSTADO_')]
features_disponiveis.extend(features_dia_mes[:10])  # Primeiros 10 para evitar excesso

print(f"‚úì Features selecionadas: {len(features_disponiveis)}")
print(f"  Principais: {features_disponiveis[:8]}")

# Criar DataFrame apenas com features selecionadas
df_features = df_merged[['AGENCIA', 'DATA'] + features_disponiveis].copy()

# Verificar e tratar valores missing
missing_count = df_features[features_disponiveis].isnull().sum().sum()
if missing_count > 0:
    print(f"‚ö†Ô∏è  Tratando {missing_count} valores missing...")
    df_features[features_disponiveis] = df_features[features_disponiveis].fillna(0)

return features_disponiveis, df_features[features_disponiveis]
```

def executar_analise_covariate_shift(df_merged, epsilon=0.92, threshold_mult=20,
min_consecutivos=3, janela_analise=30):
‚Äú‚Äù‚Äù
Executa an√°lise de covariate shift nas features de entrada.

```
Args:
    df_merged: DataFrame com dados completos
    epsilon: Par√¢metro do power martingale
    threshold_mult: Multiplicador do threshold
    min_consecutivos: M√≠nimo de detec√ß√µes consecutivas
    janela_analise: Janela para an√°lise
    
Returns:
    resultados_covariate: Dicion√°rio com resultados da an√°lise
"""
print("\n\nüîç AN√ÅLISE DE COVARIATE SHIFT")
print("="*50)

# Selecionar features relevantes
features_selecionadas, df_features = selecionar_features_relevantes(df_merged)

if len(features_selecionadas) == 0:
    print("‚ùå Nenhuma feature selecionada para an√°lise!")
    return {}

print(f"\n‚ñ∂Ô∏è  Analisando {len(features_selecionadas)} features...")
print(f"   Per√≠odo: {len(df_features)} observa√ß√µes")

# Calcular p-valores multivariados para as features
print("   Calculando p-valores multivariados...")
p_det_features, p_rnd_features = calcular_pvalores_multivariado_features(df_features)

# Power martingale
print("   Calculando Power Martingale...")
mart_power_features = power_martingale(p_rnd_features, epsilon)

# Simple Jumper martingale
print("   Calculando Simple Jumper Martingale...")
mart_jumper_features = simple_jumper_martingale(p_rnd_features)

# Detectar mudan√ßas
print("   Detectando mudan√ßas...")
deteccoes_power, info_power = detectar_mudanca_adaptativa(
    mart_power_features, 
    janela=janela_analise,
    threshold_mult=threshold_mult,
    min_consecutivos=min_consecutivos
)

deteccoes_jumper, info_jumper = detectar_mudanca_adaptativa(
    mart_jumper_features,
    janela=janela_analise,
    threshold_mult=threshold_mult,
    min_consecutivos=min_consecutivos
)

print(f"\n‚úì Detec√ß√µes Power Martingale: {len(deteccoes_power)}")
print(f"‚úì Detec√ß√µes Simple Jumper: {len(deteccoes_jumper)}")

if deteccoes_power:
    print(f"  Primeira detec√ß√£o (Power): √≠ndice {deteccoes_power[0]}")
if deteccoes_jumper:
    print(f"  Primeira detec√ß√£o (Jumper): √≠ndice {deteccoes_jumper[0]}")

# An√°lise de contribui√ß√£o por feature
contribuicoes_features = analisar_contribuicao_features(
    df_features, deteccoes_power, features_selecionadas
)

resultados_covariate = {
    'features_analisadas': features_selecionadas,
    'df_features': df_features,
    'p_valores': {'det': p_det_features, 'rnd': p_rnd_features},
    'martingale_power': mart_power_features,
    'martingale_jumper': mart_jumper_features,
    'deteccoes_power': deteccoes_power,
    'deteccoes_jumper': deteccoes_jumper,
    'info_power': info_power,
    'info_jumper': info_jumper,
    'contribuicoes_features': contribuicoes_features
}

return resultados_covariate
```

def calcular_pvalores_multivariado_features(df_features, rtol=1e-3, atol=1e-3):
‚Äú‚Äù‚Äù
Calcula p-valores conformais multivariados para features.
Adaptado para trabalhar especificamente com features de calend√°rio.

```
Args:
    df_features: DataFrame com features selecionadas
    rtol, atol: Toler√¢ncias para compara√ß√£o
    
Returns:
    p_det: P-valores determin√≠sticos
    p_rnd: P-valores randomizados
"""
df_features = df_features.reset_index(drop=True)
N = len(df_features)
p_det = np.zeros(N)
p_rnd = np.zeros(N)

print(f"   Calculando para {N} observa√ß√µes...")

for n in tqdm(range(N), desc="   Processando"):
    if n == 0:
        p_det[0] = 1
        p_rnd[0] = 1
        continue
    
    # Ponto atual
    ponto_atual = df_features.iloc[n].values
    
    # Calcular dist√¢ncias aos pontos anteriores
    distancias = []
    for i in range(n + 1):
        ponto_i = df_features.iloc[i].values
        # Usar dist√¢ncia euclidiana normalizada
        dist = np.linalg.norm(ponto_atual - ponto_i) / np.sqrt(len(ponto_atual))
        distancias.append(dist)
    
    distancias = np.array(distancias)
    dist_atual = distancias[n]
    
    # P-valor determin√≠stico
    p_det[n] = np.mean(distancias >= dist_atual)
    
    # P-valor randomizado
    countG = np.sum(distancias > dist_atual)
    countE = np.sum(np.isclose(distancias, dist_atual, rtol=rtol, atol=atol))
    u = np.random.uniform() if countE > 0 else 0
    p_rnd[n] = (countG + u * countE) / (n + 1)

return p_det, p_rnd
```

def analisar_contribuicao_features(df_features, deteccoes, features_selecionadas):
‚Äú‚Äù‚Äù
Analisa quais features mais contribuem para as detec√ß√µes de drift.

```
Args:
    df_features: DataFrame com features
    deteccoes: Lista de √≠ndices de detec√ß√£o
    features_selecionadas: Lista de nomes das features
    
Returns:
    contribuicoes: Dicion√°rio com an√°lise de contribui√ß√£o
"""
if not deteccoes:
    return {}

print("   Analisando contribui√ß√£o por feature...")

# Para cada detec√ß√£o, calcular mudan√ßa relativa em cada feature
contribuicoes = {}

for det_idx in deteccoes[:3]:  # Analisar primeiras 3 detec√ß√µes
    if det_idx < 30:  # Precisamos de hist√≥rico suficiente
        continue
        
    # Per√≠odo antes da detec√ß√£o (30 dias)
    periodo_antes = df_features.iloc[det_idx-30:det_idx]
    
    # Per√≠odo da detec√ß√£o (10 dias ap√≥s)
    periodo_deteccao = df_features.iloc[det_idx:min(det_idx+10, len(df_features))]
    
    if len(periodo_deteccao) == 0:
        continue
    
    # Calcular mudan√ßas por feature
    mudancas_features = {}
    
    for feature in features_selecionadas:
        if feature in df_features.columns:
            # M√©dia antes vs durante detec√ß√£o
            media_antes = periodo_antes[feature].mean()
            media_deteccao = periodo_deteccao[feature].mean()
            
            # Mudan√ßa relativa (evitar divis√£o por zero)
            if abs(media_antes) > 1e-6:
                mudanca_rel = abs(media_deteccao - media_antes) / abs(media_antes)
            else:
                mudanca_rel = abs(media_deteccao - media_antes)
            
            mudancas_features[feature] = mudanca_rel
    
    contribuicoes[f'deteccao_{det_idx}'] = mudancas_features

# Ranking geral de features mais impactantes
if contribuicoes:
    todas_mudancas = {}
    for det_dict in contribuicoes.values():
        for feature, mudanca in det_dict.items():
            if feature not in todas_mudancas:
                todas_mudancas[feature] = []
            todas_mudancas[feature].append(mudanca)
    
    # M√©dia das mudan√ßas por feature
    ranking_features = {}
    for feature, mudancas in todas_mudancas.items():
        ranking_features[feature] = np.mean(mudancas)
    
    # Ordenar por impacto
    features_ordenadas = sorted(ranking_features.items(), 
                               key=lambda x: x[1], reverse=True)
    
    contribuicoes['ranking_geral'] = features_ordenadas[:10]  # Top 10
    
    print(f"   Top 3 features com maior drift:")
    for i, (feature, score) in enumerate(features_ordenadas[:3]):
        print(f"     {i+1}. {feature}: {score:.3f}")

return contribuicoes
```

def plot_analise_covariate_shift(resultados_covariate, df_merged,
data_pandemia=‚Äò2020-03-01‚Äô):
‚Äú‚Äù‚Äù
Visualiza resultados da an√°lise de covariate shift.

```
Args:
    resultados_covariate: Resultados da an√°lise
    df_merged: DataFrame original
    data_pandemia: Data de refer√™ncia para pandemia
"""
if not resultados_covariate:
    print("‚ö†Ô∏è  Sem resultados para plotar!")
    return

fig, axes = plt.subplots(2, 2, figsize=(16, 10))

# 1. Evolu√ß√£o dos Martingales
ax1 = axes[0, 0]
mart_power = resultados_covariate['martingale_power']
mart_jumper = resultados_covariate['martingale_jumper']

ax1.plot(mart_power, label='Power Martingale', linewidth=2, color='blue')
ax1.plot(mart_jumper, label='Simple Jumper', linewidth=2, color='red', linestyle='--')

# Marcar detec√ß√µes
for det_idx in resultados_covariate['deteccoes_power']:
    ax1.axvline(det_idx, color='blue', linestyle=':', alpha=0.7)

for det_idx in resultados_covariate['deteccoes_jumper']:
    ax1.axvline(det_idx, color='red', linestyle=':', alpha=0.7)

ax1.set_yscale('log')
ax1.set_xlabel('Tempo')
ax1.set_ylabel('Martingale (log)')
ax1.set_title('Martingales - Covariate Shift')
ax1.legend()
ax1.grid(True, alpha=0.3)

# 2. P-valores ao longo do tempo
ax2 = axes[0, 1]
p_valores = resultados_covariate['p_valores']['rnd']
ax2.plot(p_valores, color='green', linewidth=1)
ax2.axhline(y=0.05, color='red', linestyle='--', alpha=0.7, label='Œ±=0.05')
ax2.set_xlabel('Tempo')
ax2.set_ylabel('P-valor')
ax2.set_title('P-valores Conformais - Features')
ax2.legend()
ax2.grid(True, alpha=0.3)

# 3. Ranking de contribui√ß√£o das features
ax3 = axes[1, 0]
if 'ranking_geral' in resultados_covariate['contribuicoes_features']:
    ranking = resultados_covariate['contribuicoes_features']['ranking_geral']
    features_nomes = [item[0] for item in ranking[:10]]
    features_scores = [item[1] for item in ranking[:10]]
    
    y_pos = np.arange(len(features_nomes))
    ax3.barh(y_pos, features_scores, color='skyblue')
    ax3.set_yticks(y_pos)
    ax3.set_yticklabels(features_nomes, fontsize=8)
    ax3.set_xlabel('Score de Mudan√ßa')
    ax3.set_title('Features com Maior Drift')
    ax3.grid(True, axis='x', alpha=0.3)

# 4. Boxplot de algumas features principais
ax4 = axes[1, 1]
if 'ranking_geral' in resultados_covariate['contribuicoes_features']:
    ranking = resultados_covariate['contribuicoes_features']['ranking_geral']
    top_feature = ranking[0][0] if ranking else None
    
    if top_feature and top_feature in df_merged.columns:
        # Dividir dados em pr√© e p√≥s primeira detec√ß√£o
        deteccoes = resultados_covariate['deteccoes_power']
        if deteccoes:
            primeiro_drift = deteccoes[0]
            
            antes = df_merged.iloc[:primeiro_drift][top_feature]
            depois = df_merged.iloc[primeiro_drift:][top_feature]
            
            data_plot = [antes.dropna(), depois.dropna()]
            labels = ['Antes Drift', 'Ap√≥s Drift']
            
            ax4.boxplot(data_plot, labels=labels)
            ax4.set_title(f'Distribui√ß√£o: {top_feature}')
            ax4.set_ylabel('Valor')
            ax4.grid(True, alpha=0.3)

plt.suptitle('An√°lise de Covariate Shift - Features de Entrada', fontsize=16)
plt.tight_layout()
plt.show()
```

def comparar_drift_types(resultados_univariado, resultados_multivariado,
resultados_covariate, df_merged):
‚Äú‚Äù‚Äù
Compara os tr√™s tipos de an√°lise de drift implementados.

```
Args:
    resultados_univariado: Resultados da an√°lise univariada
    resultados_multivariado: Resultados da an√°lise multivariada original
    resultados_covariate: Resultados da an√°lise de covariate shift
    df_merged: DataFrame original
"""
print("\n\nüìä COMPARA√á√ÉO ENTRE TIPOS DE DRIFT")
print("="*50)

fig, axes = plt.subplots(3, 1, figsize=(15, 12))

# 1. Concept Drift (erros univariados)
ax1 = axes[0]
cores = ['blue', 'green', 'orange', 'purple']
variaveis = ['SAQ', 'DEP', 'SAQCEI', 'DEPCEI']

for idx, var in enumerate(variaveis):
    if var in resultados_univariado:
        mart = resultados_univariado[var]['martingale_power']
        ax1.plot(mart, label=f'{var}', color=cores[idx], alpha=0.7)
        
        # Marcar detec√ß√µes
        deteccoes = resultados_univariado[var]['deteccoes']
        for det in deteccoes:
            ax1.axvline(det, color=cores[idx], linestyle=':', alpha=0.5)

ax1.set_yscale('log')
ax1.set_ylabel('Martingale (log)')
ax1.set_title('Concept Drift - Erros de Predi√ß√£o por Vari√°vel')
ax1.legend()
ax1.grid(True, alpha=0.3)

# 2. Performance Drift (erros multivariados)
ax2 = axes[1]
mart_multi = resultados_multivariado['martingale_power']
ax2.plot(mart_multi, color='red', linewidth=2, label='Multivariado')

# Marcar detec√ß√µes
for det in resultados_multivariado['deteccoes']:
    ax2.axvline(det, color='red', linestyle='--', alpha=0.7)

ax2.set_yscale('log')
ax2.set_ylabel('Martingale (log)')
ax2.set_title('Performance Drift - Erro Conjunto das Vari√°veis')
ax2.legend()
ax2.grid(True, alpha=0.3)

# 3. Covariate Shift (features de entrada)
ax3 = axes[2]
if resultados_covariate:
    mart_cov_power = resultados_covariate['martingale_power']
    mart_cov_jumper = resultados_covariate['martingale_jumper']
    
    ax3.plot(mart_cov_power, color='darkgreen', linewidth=2, label='Power Martingale')
    ax3.plot(mart_cov_jumper, color='brown', linewidth=2, 
            linestyle='--', label='Simple Jumper')
    
    # Marcar detec√ß√µes
    for det in resultados_covariate['deteccoes_power']:
        ax3.axvline(det, color='darkgreen', linestyle=':', alpha=0.7)
    
    for det in resultados_covariate['deteccoes_jumper']:
        ax3.axvline(det, color='brown', linestyle=':', alpha=0.7)

ax3.set_yscale('log')
ax3.set_xlabel('Tempo')
ax3.set_ylabel('Martingale (log)')
ax3.set_title('Covariate Shift - Mudan√ßa nas Features de Entrada')
ax3.legend()
ax3.grid(True, alpha=0.3)

plt.suptitle('Compara√ß√£o: Concept Drift vs Performance Drift vs Covariate Shift', 
            fontsize=16)
plt.tight_layout()
plt.show()

# Resumo quantitativo
print("\nüìã RESUMO QUANTITATIVO:")
print("-" * 30)

# Concept drift
total_det_concept = sum(len(resultados_univariado[var]['deteccoes']) 
                       for var in variaveis if var in resultados_univariado)
print(f"Concept Drift (univariado): {total_det_concept} detec√ß√µes totais")

# Performance drift
total_det_performance = len(resultados_multivariado['deteccoes'])
print(f"Performance Drift (multivariado): {total_det_performance} detec√ß√µes")

# Covariate shift
if resultados_covariate:
    total_det_covariate = len(resultados_covariate['deteccoes_power'])
    print(f"Covariate Shift (features): {total_det_covariate} detec√ß√µes")

print("\nüí° INTERPRETA√á√ÉO:")
print("-" * 30)
print("‚Ä¢ Concept Drift: Mudan√ßa na rela√ß√£o features ‚Üí target espec√≠fica por vari√°vel")
print("‚Ä¢ Performance Drift: Degrada√ß√£o geral do modelo (m√∫ltiplas vari√°veis)")
print("‚Ä¢ Covariate Shift: Mudan√ßa no padr√£o dos dados de entrada")
```

# =============================================================================

# MODIFICA√á√ÉO DA FUN√á√ÉO PRINCIPAL PARA INCLUIR COVARIATE SHIFT

# =============================================================================

def executar_analise_drift_completa(df_merged, janelas=[7, 30, 90], epsilon=0.92,
threshold_mult=20, min_consecutivos=3):
‚Äú‚Äù‚Äù
Vers√£o estendida da fun√ß√£o principal que inclui an√°lise de covariate shift.
‚Äú‚Äù‚Äù
print(‚Äù\nüöÄ INICIANDO AN√ÅLISE COMPLETA DE DRIFT‚Ä¶\n‚Äù)

```
# An√°lise original (concept + performance drift)
resultados_originais = executar_analise_drift(
    df_merged, janelas, epsilon, threshold_mult, min_consecutivos
)

# Nova an√°lise: Covariate shift
resultados_covariate = executar_analise_covariate_shift(
    df_merged, epsilon, threshold_mult, min_consecutivos, janelas[1]
)

# Compilar resultados completos
resultados_completos = {
    'univariado': resultados_originais['univariado'],
    'multivariado': resultados_originais['multivariado'],
    'covariate_shift': resultados_covariate,
    'janelas': resultados_originais['janelas'],
    'config': resultados_originais['config']
}

# Visualiza√ß√µes comparativas
if resultados_covariate:
    print("\nüìà GERANDO VISUALIZA√á√ïES ESTENDIDAS...")
    
    # Plot espec√≠fico do covariate shift
    plot_analise_covariate_shift(resultados_covariate, df_merged)
    
    # Compara√ß√£o entre todos os tipos
    comparar_drift_types(
        resultados_originais['univariado'],
        resultados_originais['multivariado'], 
        resultados_covariate,
        df_merged
    )

return resultados_completos
```

# =============================================================================

# EXEMPLO DE USO MODIFICADO

# =============================================================================

‚Äú‚Äù‚Äù

# Para usar a nova funcionalidade, substitua a chamada original:

# ANTES:

# resultados = executar_analise_drift(df_merged, ‚Ä¶)

# DEPOIS:

resultados_completos = executar_analise_drift_completa(
df_merged,
janelas=[7, 30, 90],
epsilon=0.92,
threshold_mult=20,
min_consecutivos=3
)

# Acessar resultados:

covariate_results = resultados_completos[‚Äòcovariate_shift‚Äô]
if covariate_results[‚Äòdeteccoes_power‚Äô]:
print(‚ÄúCovariate shift detectado!‚Äù)
print(f‚ÄùFeatures mais impactantes: {covariate_results[‚Äòcontribuicoes_features‚Äô][‚Äòranking_geral‚Äô][:3]}‚Äù)
‚Äú‚Äù‚Äù